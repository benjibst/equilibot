<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Equilibot Telemetry</title>
  <style>
    :root {
      --bg-a: #f4f6f8;
      --bg-b: #dbe8ef;
      --panel: #ffffff;
      --ink: #1d2a36;
      --muted: #5c7283;
      --x: #1b76d1;
      --y: #1d9d75;
      --z: #d43a4f;
      --line: #d3dde4;
      --online: #1f8f5f;
      --offline: #b04040;
      --pending: #b67912;
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      font-family: "Space Grotesk", "Trebuchet MS", sans-serif;
      color: var(--ink);
      background: radial-gradient(circle at 15% 0, #ffffff 0%, var(--bg-a) 35%, var(--bg-b) 100%);
    }

    .wrap {
      max-width: 1100px;
      margin: 0 auto;
      padding: 1.2rem;
      display: grid;
      gap: 1rem;
    }

    .top {
      background: var(--panel);
      border: 1px solid #e3e8ed;
      border-radius: 14px;
      padding: 1rem;
      display: flex;
      justify-content: space-between;
      gap: 1rem;
      flex-wrap: wrap;
      box-shadow: 0 8px 24px rgba(37, 74, 103, 0.08);
    }

    h1 {
      margin: 0;
      font-size: 1.3rem;
      letter-spacing: 0.04em;
      text-transform: uppercase;
    }

    .status {
      font-weight: 700;
    }

    .status.online {
      color: var(--online);
    }

    .status.offline {
      color: var(--offline);
    }

    .status.pending {
      color: var(--pending);
    }

    .panel {
      background: var(--panel);
      border: 1px solid #e3e8ed;
      border-radius: 14px;
      padding: 0.9rem 1rem;
      box-shadow: 0 8px 24px rgba(37, 74, 103, 0.08);
    }

    .panel h2 {
      margin: 0 0 0.5rem 0;
      font-size: 1rem;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      color: var(--muted);
    }

    .config-grid {
      display: grid;
      grid-template-columns: repeat(3, minmax(170px, 1fr));
      gap: 0.65rem 0.9rem;
      align-items: end;
    }

    .field {
      display: grid;
      gap: 0.25rem;
    }

    .field label {
      color: var(--muted);
      font-size: 0.82rem;
      text-transform: uppercase;
      letter-spacing: 0.04em;
      font-weight: 700;
    }

    .field select {
      width: 100%;
      border: 1px solid #ccd8e2;
      border-radius: 10px;
      padding: 0.42rem 0.5rem;
      background: #ffffff;
      color: var(--ink);
      font-size: 0.94rem;
    }

    .config-actions {
      grid-column: 1 / -1;
      display: flex;
      gap: 0.75rem;
      align-items: center;
      margin-top: 0.25rem;
    }

    .config-actions button {
      border: 1px solid #2c7fb3;
      background: #2c7fb3;
      color: #ffffff;
      border-radius: 10px;
      padding: 0.42rem 0.75rem;
      font-weight: 700;
      cursor: pointer;
    }

    .config-actions button:disabled {
      opacity: 0.55;
      cursor: not-allowed;
    }

    .cfg-status {
      color: var(--muted);
      font-size: 0.85rem;
      font-weight: 700;
    }

    .cfg-status.err {
      color: var(--offline);
    }

    .orientation-grid {
      display: grid;
      grid-template-columns: minmax(260px, 1fr);
      gap: 1rem;
      justify-content: start;
    }

    .orientation-card {
      border: 1px solid #d8e2ea;
      border-radius: 12px;
      padding: 0.65rem;
      background: #f8fbfd;
    }

    .orientation-title {
      font-size: 0.78rem;
      font-weight: 700;
      letter-spacing: 0.04em;
      text-transform: uppercase;
      color: var(--muted);
      margin-bottom: 0.45rem;
    }

    .orientation-value {
      margin-top: 0.45rem;
      font-size: 0.86rem;
      font-weight: 700;
      color: #41596b;
      font-family: "Fira Code", "Consolas", "Monaco", monospace;
      letter-spacing: 0.02em;
    }

    .charts {
      display: grid;
      grid-template-columns: 1fr;
      gap: 1rem;
    }

    .chart-card {
      background: var(--panel);
      border: 1px solid #e3e8ed;
      border-radius: 14px;
      padding: 0.8rem;
      box-shadow: 0 8px 24px rgba(37, 74, 103, 0.08);
    }

    .chart-head {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 1rem;
      margin-bottom: 0.4rem;
    }

    .chart-title {
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      color: var(--muted);
    }

    .legend {
      display: flex;
      gap: 0.8rem;
      font-size: 0.83rem;
    }

    .legend span {
      display: inline-flex;
      align-items: center;
      gap: 0.35rem;
    }

    .dot {
      width: 0.65rem;
      height: 0.65rem;
      border-radius: 50%;
    }

    .dot.x {
      background: var(--x);
    }

    .dot.y {
      background: var(--y);
    }

    .dot.z {
      background: var(--z);
    }

    canvas {
      width: 100%;
      height: 250px;
      display: block;
      border-radius: 10px;
      background: #f9fbfc;
      border: 1px solid var(--line);
    }

    .quat-canvas {
      height: min(62vw, 340px);
      min-height: 220px;
    }

    @media (max-width: 900px) {
      .config-grid {
        grid-template-columns: 1fr;
      }
    }
  </style>
</head>

<body>
  <main class="wrap">
    <section class="top">
      <h1>Equilibot Live Telemetry</h1>
      <div class="status pending" id="wsStatus">Connecting...</div>
    </section>

    <section class="panel">
      <h2>IMU Runtime Config</h2>
      <div class="config-grid">
        <div class="field">
          <label for="cfgAccOdr">Accel ODR</label>
          <select id="cfgAccOdr"></select>
        </div>
        <div class="field">
          <label for="cfgGyroOdr">Gyro ODR</label>
          <select id="cfgGyroOdr"></select>
        </div>
        <div class="field">
          <label for="cfgAccFs">Accel Full Scale</label>
          <select id="cfgAccFs"></select>
        </div>
        <div class="field">
          <label for="cfgGyroFs">Gyro Full Scale</label>
          <select id="cfgGyroFs"></select>
        </div>
        <div class="field">
          <label for="cfgAccBw">Accel LPF BW</label>
          <select id="cfgAccBw"></select>
        </div>
        <div class="field">
          <label for="cfgGyroBw">Gyro LPF BW</label>
          <select id="cfgGyroBw"></select>
        </div>
        <div class="config-actions">
          <button id="cfgApplyBtn" type="button">Apply IMU Config</button>
          <span id="cfgStatus" class="cfg-status">No pending changes</span>
        </div>
      </div>
    </section>

    <section class="panel">
      <h2>Orientation</h2>
      <div class="orientation-grid">
        <article class="orientation-card">
          <div class="orientation-title">Simple Rot Quaternion</div>
          <canvas id="orientationCanvas" class="quat-canvas"></canvas>
          <div class="orientation-value" id="orientationQuatValue">w=1.000 x=0.000 y=0.000 z=0.000</div>
        </article>
      </div>
    </section>

    <section class="charts">
      <article class="chart-card">
        <div class="chart-head">
          <div class="chart-title">Acceleration Over Time</div>
          <div class="legend">
            <span><i class="dot x"></i>X</span>
            <span><i class="dot y"></i>Y</span>
            <span><i class="dot z"></i>Z</span>
          </div>
        </div>
        <canvas id="accChart"></canvas>
      </article>
      <article class="chart-card">
        <div class="chart-head">
          <div class="chart-title">Gyroscope Over Time</div>
          <div class="legend">
            <span><i class="dot x"></i>X</span>
            <span><i class="dot y"></i>Y</span>
            <span><i class="dot z"></i>Z</span>
          </div>
        </div>
        <canvas id="gyroChart"></canvas>
      </article>
    </section>
  </main>

  <script>
    const CHART_WINDOW_US = 5000000;
    const COLORS = { x: "#1b76d1", y: "#1d9d75", z: "#d43a4f" };

    const accRaw = { t: [], x: [], y: [], z: [] };
    const gyroRaw = { t: [], x: [], y: [], z: [] };
    const wsStatus = document.getElementById("wsStatus");
    const accChart = document.getElementById("accChart");
    const gyroChart = document.getElementById("gyroChart");
    const cfgApplyBtn = document.getElementById("cfgApplyBtn");
    const cfgStatus = document.getElementById("cfgStatus");
    const cfgAccOdr = document.getElementById("cfgAccOdr");
    const cfgGyroOdr = document.getElementById("cfgGyroOdr");
    const cfgAccFs = document.getElementById("cfgAccFs");
    const cfgGyroFs = document.getElementById("cfgGyroFs");
    const cfgAccBw = document.getElementById("cfgAccBw");
    const cfgGyroBw = document.getElementById("cfgGyroBw");
    const orientationCanvas = document.getElementById("orientationCanvas");
    const orientationQuatValue = document.getElementById("orientationQuatValue");

    const DEFAULT_IMU_CONFIG = {
      acce_odr: 7,
      gyro_odr: 7,
      acce_fs: 3,
      gyro_fs: 3,
      acce_bw: 0,
      gyro_bw: 0,
    };
    const ACC_ODR_TO_HZ = {
      5: 1600,
      6: 800,
      7: 400,
      8: 200,
      9: 100,
      10: 50,
      11: 25,
      12: 12.5,
      13: 6.25,
      14: 3.125,
      15: 1.5625,
    };
    const GYRO_ODR_TO_HZ = {
      5: 1600,
      6: 800,
      7: 400,
      8: 200,
      9: 100,
      10: 50,
      11: 25,
      12: 12.5,
    };
    const ACC_FS_TO_G = {
      0: 16,
      1: 8,
      2: 4,
      3: 2,
    };
    const GYRO_FS_TO_DPS = {
      0: 2000,
      1: 1000,
      2: 500,
      3: 250,
    };
    let chartMaxPoints = 2;
    let chartAccFullScaleG = 2;
    let chartGyroFullScaleDps = 250;
    let currentQuaternion = { w: 1, x: 0, y: 0, z: 0 };

    const ACC_ODR_OPTIONS = [
      { value: 5, label: "1600 Hz" },
      { value: 6, label: "800 Hz" },
      { value: 7, label: "400 Hz" },
      { value: 8, label: "200 Hz" },
      { value: 9, label: "100 Hz" },
      { value: 10, label: "50 Hz" },
      { value: 11, label: "25 Hz" },
      { value: 12, label: "12.5 Hz" },
      { value: 13, label: "6.25 Hz" },
      { value: 14, label: "3.125 Hz" },
      { value: 15, label: "1.5625 Hz" },
    ];
    const GYRO_ODR_OPTIONS = [
      { value: 5, label: "1600 Hz" },
      { value: 6, label: "800 Hz" },
      { value: 7, label: "400 Hz" },
      { value: 8, label: "200 Hz" },
      { value: 9, label: "100 Hz" },
      { value: 10, label: "50 Hz" },
      { value: 11, label: "25 Hz" },
      { value: 12, label: "12.5 Hz" },
    ];
    const ACC_FS_OPTIONS = [
      { value: 0, label: "±16 g" },
      { value: 1, label: "±8 g" },
      { value: 2, label: "±4 g" },
      { value: 3, label: "±2 g" },
    ];
    const GYRO_FS_OPTIONS = [
      { value: 0, label: "±2000 dps" },
      { value: 1, label: "±1000 dps" },
      { value: 2, label: "±500 dps" },
      { value: 3, label: "±250 dps" },
    ];
    const BW_OPTIONS = [
      { value: 0, label: "Bypass" },
      { value: 1, label: "180 Hz" },
      { value: 2, label: "121 Hz" },
      { value: 3, label: "73 Hz" },
      { value: 4, label: "53 Hz" },
      { value: 5, label: "34 Hz" },
      { value: 6, label: "25 Hz" },
      { value: 7, label: "16 Hz" },
    ];

    function setStatus(text, mode) {
      wsStatus.textContent = text;
      wsStatus.className = "status " + mode;
    }

    function setCfgStatus(text, isError) {
      cfgStatus.textContent = text;
      cfgStatus.className = isError ? "cfg-status err" : "cfg-status";
    }

    function populateSelect(selectElement, options, selectedValue) {
      selectElement.textContent = "";
      for (const option of options) {
        const node = document.createElement("option");
        node.value = String(option.value);
        node.textContent = option.label;
        if (option.value === selectedValue) {
          node.selected = true;
        }
        selectElement.appendChild(node);
      }
    }

    function normalizeQuaternion(quaternion) {
      const magnitude = Math.hypot(quaternion.w, quaternion.x, quaternion.y, quaternion.z);
      if (!Number.isFinite(magnitude) || magnitude < 1e-6) {
        return { w: 1, x: 0, y: 0, z: 0 };
      }
      return {
        w: quaternion.w / magnitude,
        x: quaternion.x / magnitude,
        y: quaternion.y / magnitude,
        z: quaternion.z / magnitude,
      };
    }

    function parseSimpleRotQuaternion(simpleRot) {
      if (!simpleRot) {
        return null;
      }
      if (Array.isArray(simpleRot) && simpleRot.length >= 4) {
        const parsed = {
          w: Number(simpleRot[0]),
          x: Number(simpleRot[1]),
          y: Number(simpleRot[2]),
          z: Number(simpleRot[3]),
        };
        if (Number.isFinite(parsed.w) && Number.isFinite(parsed.x) &&
          Number.isFinite(parsed.y) && Number.isFinite(parsed.z)) {
          return normalizeQuaternion(parsed);
        }
        return null;
      }
      const parsed = {
        w: Number(simpleRot.w),
        x: Number(simpleRot.x),
        y: Number(simpleRot.y),
        z: Number(simpleRot.z),
      };
      if (Number.isFinite(parsed.w) && Number.isFinite(parsed.x) &&
        Number.isFinite(parsed.y) && Number.isFinite(parsed.z)) {
        return normalizeQuaternion(parsed);
      }
      return null;
    }

    function updateOrientationFromMessage(message) {
      const parsed = parseSimpleRotQuaternion(message.simple_rot);
      if (!parsed) {
        return;
      }
      currentQuaternion = parsed;
      orientationQuatValue.textContent =
        `w=${parsed.w.toFixed(3)} x=${parsed.x.toFixed(3)} y=${parsed.y.toFixed(3)} z=${parsed.z.toFixed(3)}`;
    }

    function trimSeries(series) {
      const count = series.t.length;
      if (count === 0) {
        return;
      }

      const latestTs = series.t[count - 1];
      if (Number.isFinite(latestTs)) {
        const minAllowedTs = latestTs - CHART_WINDOW_US;
        let firstValidIndex = 0;
        while (firstValidIndex < series.t.length && series.t[firstValidIndex] < minAllowedTs) {
          firstValidIndex += 1;
        }
        if (firstValidIndex > 0) {
          series.t.splice(0, firstValidIndex);
          series.x.splice(0, firstValidIndex);
          series.y.splice(0, firstValidIndex);
          series.z.splice(0, firstValidIndex);
        }
      }

      const dropCount = series.t.length - chartMaxPoints;
      if (dropCount > 0) {
        series.t.splice(0, dropCount);
        series.x.splice(0, dropCount);
        series.y.splice(0, dropCount);
        series.z.splice(0, dropCount);
      }
    }

    function readConfigFromForm() {
      return {
        acce_odr: Number(cfgAccOdr.value),
        gyro_odr: Number(cfgGyroOdr.value),
        acce_fs: Number(cfgAccFs.value),
        gyro_fs: Number(cfgGyroFs.value),
        acce_bw: Number(cfgAccBw.value),
        gyro_bw: Number(cfgGyroBw.value),
      };
    }

    function applyChartSettingsFromConfig(config) {
      const accOdrHz = ACC_ODR_TO_HZ[config.acce_odr] ?? 100;
      const gyroOdrHz = GYRO_ODR_TO_HZ[config.gyro_odr] ?? 100;
      const sampleRateHz = Math.max(accOdrHz, gyroOdrHz);
      chartMaxPoints = Math.max(2, Math.ceil((CHART_WINDOW_US * sampleRateHz) / 1000000));
      chartAccFullScaleG = ACC_FS_TO_G[config.acce_fs] ?? 2;
      chartGyroFullScaleDps = GYRO_FS_TO_DPS[config.gyro_fs] ?? 250;
      trimSeries(accRaw);
      trimSeries(gyroRaw);
    }

    function initConfigForm() {
      populateSelect(cfgAccOdr, ACC_ODR_OPTIONS, DEFAULT_IMU_CONFIG.acce_odr);
      populateSelect(cfgGyroOdr, GYRO_ODR_OPTIONS, DEFAULT_IMU_CONFIG.gyro_odr);
      populateSelect(cfgAccFs, ACC_FS_OPTIONS, DEFAULT_IMU_CONFIG.acce_fs);
      populateSelect(cfgGyroFs, GYRO_FS_OPTIONS, DEFAULT_IMU_CONFIG.gyro_fs);
      populateSelect(cfgAccBw, BW_OPTIONS, DEFAULT_IMU_CONFIG.acce_bw);
      populateSelect(cfgGyroBw, BW_OPTIONS, DEFAULT_IMU_CONFIG.gyro_bw);
      applyChartSettingsFromConfig(DEFAULT_IMU_CONFIG);
      cfgApplyBtn.disabled = true;
      cfgApplyBtn.addEventListener("click", () => {
        if (!ws || ws.readyState !== WebSocket.OPEN) {
          setCfgStatus("WebSocket is not connected", true);
          return;
        }

        const selectedConfig = readConfigFromForm();
        const configMessage = {
          type: "imu_config",
          config: selectedConfig,
        };

        ws.send(JSON.stringify(configMessage));
        applyChartSettingsFromConfig(selectedConfig);
        setCfgStatus("IMU config sent", false);
      });
    }

    function pushTelemetryBatch(series, rows) {
      if (!Array.isArray(rows)) {
        return;
      }
      for (const row of rows) {
        if (!row || !Array.isArray(row.data) || row.data.length < 3) {
          continue;
        }
        let ts = Number(row.ts_us);
        if (!Number.isFinite(ts)) {
          const tsMs = Number(row.ts_us);
          if (Number.isFinite(tsMs)) {
            ts = tsMs * 1000000.0;
          }
        }
        const x = Number(row.data[0]);
        const y = Number(row.data[1]);
        const z = Number(row.data[2]);
        if (!Number.isFinite(ts) || !Number.isFinite(x) || !Number.isFinite(y) || !Number.isFinite(z)) {
          continue;
        }
        series.t.push(ts);
        series.x.push(x);
        series.y.push(y);
        series.z.push(z);
      }
      trimSeries(series);
    }

    function fmtTsSeconds(tsUs) {
      return Number.isFinite(tsUs) ? (tsUs / 1000000).toFixed(3) + "s" : "--";
    }

    function resizeCanvas(canvas, minCssWidth, minCssHeight) {
      const rect = canvas.getBoundingClientRect();
      const dpr = window.devicePixelRatio || 1;
      const width = Math.max(Math.floor(minCssWidth * dpr), Math.floor(rect.width * dpr));
      const height = Math.max(Math.floor(minCssHeight * dpr), Math.floor(rect.height * dpr));
      if (canvas.width !== width || canvas.height !== height) {
        canvas.width = width;
        canvas.height = height;
      }
    }

    function quaternionToMatrix(quaternion) {
      const { w, x, y, z } = quaternion;
      const xx = x * x;
      const yy = y * y;
      const zz = z * z;
      const xy = x * y;
      const xz = x * z;
      const yz = y * z;
      const wx = w * x;
      const wy = w * y;
      const wz = w * z;
      return [
        [1 - 2 * (yy + zz), 2 * (xy - wz), 2 * (xz + wy)],
        [2 * (xy + wz), 1 - 2 * (xx + zz), 2 * (yz - wx)],
        [2 * (xz - wy), 2 * (yz + wx), 1 - 2 * (xx + yy)],
      ];
    }

    function rotatePoint(point, matrix) {
      return [
        matrix[0][0] * point[0] + matrix[0][1] * point[1] + matrix[0][2] * point[2],
        matrix[1][0] * point[0] + matrix[1][1] * point[1] + matrix[1][2] * point[2],
        matrix[2][0] * point[0] + matrix[2][1] * point[1] + matrix[2][2] * point[2],
      ];
    }

    function projectPoint(point, width, height) {
      const cameraDistance = 3.8;
      const perspective = 1 / Math.max(0.8, cameraDistance - point[2]);
      const scale = Math.min(width, height) * 1.3;
      return {
        x: width * 0.5 + point[0] * scale * perspective,
        y: height * 0.52 - point[1] * scale * perspective,
        z: point[2],
      };
    }

    function drawOrientationBox() {
      resizeCanvas(orientationCanvas, 220, 220);
      const ctx = orientationCanvas.getContext("2d");
      const width = orientationCanvas.width;
      const height = orientationCanvas.height;

      ctx.clearRect(0, 0, width, height);
      ctx.fillStyle = "#f9fbfc";
      ctx.fillRect(0, 0, width, height);

      const matrix = quaternionToMatrix(currentQuaternion);
      const vertices = [
        [-0.8, -0.5, -0.32],
        [0.8, -0.5, -0.32],
        [0.8, 0.5, -0.32],
        [-0.8, 0.5, -0.32],
        [-0.8, -0.5, 0.32],
        [0.8, -0.5, 0.32],
        [0.8, 0.5, 0.32],
        [-0.8, 0.5, 0.32],
      ].map((point) => rotatePoint(point, matrix));

      const projected = vertices.map((point) => projectPoint(point, width, height));
      const faces = [
        { idx: [0, 1, 2, 3], fill: "#d7e5f2" },
        { idx: [4, 5, 6, 7], fill: "#a8cbeb" },
        { idx: [0, 1, 5, 4], fill: "#c5dbee" },
        { idx: [1, 2, 6, 5], fill: "#b7d2ea" },
        { idx: [2, 3, 7, 6], fill: "#cfdff0" },
        { idx: [3, 0, 4, 7], fill: "#bfd5e9" },
      ];

      faces.sort((left, right) => {
        const zLeft = left.idx.reduce((sum, index) => sum + vertices[index][2], 0) / left.idx.length;
        const zRight = right.idx.reduce((sum, index) => sum + vertices[index][2], 0) / right.idx.length;
        return zLeft - zRight;
      });

      for (const face of faces) {
        ctx.beginPath();
        for (let i = 0; i < face.idx.length; i += 1) {
          const point = projected[face.idx[i]];
          if (i === 0) {
            ctx.moveTo(point.x, point.y);
          } else {
            ctx.lineTo(point.x, point.y);
          }
        }
        ctx.closePath();
        ctx.fillStyle = face.fill;
        ctx.fill();
        ctx.lineWidth = 1.25;
        ctx.strokeStyle = "#3e5568";
        ctx.stroke();
      }

      const origin = projectPoint([0, 0, 0], width, height);
      const axisLength = 1.25;
      const axes = [
        { vector: rotatePoint([axisLength, 0, 0], matrix), color: "#1b76d1", label: "X" },
        { vector: rotatePoint([0, axisLength, 0], matrix), color: "#1d9d75", label: "Y" },
        { vector: rotatePoint([0, 0, axisLength], matrix), color: "#d43a4f", label: "Z" },
      ];
      ctx.font = "600 12px Trebuchet MS, sans-serif";
      ctx.textAlign = "left";
      ctx.textBaseline = "middle";
      for (const axis of axes) {
        const endpoint = projectPoint(axis.vector, width, height);
        ctx.beginPath();
        ctx.moveTo(origin.x, origin.y);
        ctx.lineTo(endpoint.x, endpoint.y);
        ctx.lineWidth = 2;
        ctx.strokeStyle = axis.color;
        ctx.stroke();
        ctx.fillStyle = axis.color;
        ctx.fillText(axis.label, endpoint.x + 4, endpoint.y);
      }
    }

    function drawChart(canvas, series, yMin, yMax, unitLabel, timeWindowUs) {
      resizeCanvas(canvas, 320, 180);
      const ctx = canvas.getContext("2d");
      const w = canvas.width;
      const h = canvas.height;
      const pad = { l: 58, r: 14, t: 12, b: 28 };
      const pw = w - pad.l - pad.r;
      const ph = h - pad.t - pad.b;

      ctx.clearRect(0, 0, w, h);
      ctx.fillStyle = "#f9fbfc";
      ctx.fillRect(0, 0, w, h);

      ctx.strokeStyle = "#e2e9ef";
      ctx.lineWidth = 1;
      for (let i = 0; i <= 5; i += 1) {
        const y = pad.t + (ph * i) / 5;
        ctx.beginPath();
        ctx.moveTo(pad.l, y);
        ctx.lineTo(pad.l + pw, y);
        ctx.stroke();
      }

      const yToPx = (value) => pad.t + (1 - (value - yMin) / (yMax - yMin)) * ph;
      const tsValues = series.t;
      const tCount = tsValues.length;
      const tMax = tCount > 0 ? tsValues[tCount - 1] : NaN;
      const tMin = Number.isFinite(tMax) ? tMax - timeWindowUs : NaN;
      const hasTimeRange = Number.isFinite(tMin) && Number.isFinite(tMax) && timeWindowUs > 0;
      const xToPx = (ts, fallbackIndex) => {
        if (hasTimeRange && Number.isFinite(ts)) {
          const clampedTs = Math.max(tMin, Math.min(ts, tMax));
          return pad.l + ((clampedTs - tMin) / timeWindowUs) * pw;
        }
        if (chartMaxPoints <= 1) return pad.l;
        return pad.l + (fallbackIndex / (chartMaxPoints - 1)) * pw;
      };

      ctx.strokeStyle = "#000000";
      ctx.lineWidth = 1.5;
      ctx.beginPath();
      ctx.moveTo(pad.l, yToPx(0));
      ctx.lineTo(pad.l + pw, yToPx(0));
      ctx.stroke();

      for (const axis of ["x", "y", "z"]) {
        const points = series[axis];
        if (points.length < 2) continue;
        ctx.strokeStyle = COLORS[axis];
        ctx.lineWidth = 2.0;
        ctx.beginPath();
        points.forEach((value, index) => {
          const ts = tsValues[index];
          const x = xToPx(ts, chartMaxPoints - points.length + index);
          const y = yToPx(value);
          if (index === 0) ctx.moveTo(x, y);
          else ctx.lineTo(x, y);
        });
        ctx.stroke();
      }

      ctx.fillStyle = "#5c7283";
      ctx.font = "14px Trebuchet MS, sans-serif";
      ctx.textAlign = "left";
      ctx.fillText((yMax).toFixed(2) + " " + unitLabel, 8, pad.t + 10);
      ctx.fillText((yMin).toFixed(2) + " " + unitLabel, 8, pad.t + ph);
      ctx.fillText("t0 " + fmtTsSeconds(tMin), pad.l, h - 8);
      ctx.textAlign = "center";
      ctx.fillText("span " + (timeWindowUs / 1000000).toFixed(3) + " s", pad.l + pw / 2, h - 8);
      ctx.textAlign = "right";
      ctx.fillText("t1 " + fmtTsSeconds(tMax), w - 8, h - 8);
    }

    function render() {
      drawOrientationBox();
      drawChart(accChart, accRaw, -chartAccFullScaleG, chartAccFullScaleG, "g", CHART_WINDOW_US);
      drawChart(gyroChart, gyroRaw, -chartGyroFullScaleDps, chartGyroFullScaleDps, "dps", CHART_WINDOW_US);
      requestAnimationFrame(render);
    }

    let ws = null;
    let reconnectTimer = null;

    function scheduleReconnect() {
      if (reconnectTimer !== null) {
        return;
      }
      reconnectTimer = setTimeout(() => {
        reconnectTimer = null;
        connectWebSocket();
      }, 1200);
    }

    function connectWebSocket() {
      setStatus("Connecting...", "pending");
      const protocol = window.location.protocol === "https:" ? "wss" : "ws";
      ws = new WebSocket(protocol + "://" + window.location.host + "/ws");

      ws.addEventListener("open", () => {
        setStatus("Connected", "online");
        cfgApplyBtn.disabled = false;
        setCfgStatus("Connected, ready to apply", false);
      });

      ws.addEventListener("message", (event) => {
        let message;
        try {
          message = JSON.parse(event.data);
        } catch (_ignored) {
          return;
        }

        updateOrientationFromMessage(message);

        if (Array.isArray(message.acc)) {
          pushTelemetryBatch(accRaw, message.acc);
        }
        if (Array.isArray(message.gyro)) {
          pushTelemetryBatch(gyroRaw, message.gyro);
        }
      });

      ws.addEventListener("close", () => {
        setStatus("Disconnected, retrying...", "offline");
        cfgApplyBtn.disabled = true;
        setCfgStatus("Disconnected", true);
        scheduleReconnect();
      });

      ws.addEventListener("error", () => {
        setStatus("Socket error", "offline");
        cfgApplyBtn.disabled = true;
        setCfgStatus("Socket error", true);
        if (ws && ws.readyState <= 1) {
          ws.close();
        }
      });
    }

    initConfigForm();
    render();
    connectWebSocket();
  </script>
</body>

</html>
